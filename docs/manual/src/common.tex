\begin{titlepage}
  \begin{center}

  {\Huge FT245\_SYNC\_TO\_AXIS}

  \vspace{25mm}

  \includegraphics[width=0.90\textwidth,height=\textheight,keepaspectratio]{img/AFRL.png}

  \vspace{25mm}

  \today

  \vspace{15mm}

  {\Large Jay Convertino}

  \end{center}
\end{titlepage}

\tableofcontents

\newpage

\section{Usage}

\subsection{Introduction}

\par
AXIS 1553 decoder is a core for decoding MIL-STD-1553 signals demodulated by the PMOD1553 device to AXIS data.
The input is a TTL differential signal. Meaning when diff[0] is 1 diff[1] is 0.

\subsection{Dependencies}

\par
The following are the dependencies of the cores.

\begin{itemize}
  \item fusesoc 2.X
  \item iverilog (simulation)
  \item cocotb (simulation)
\end{itemize}

\input{src/fusesoc/depend_fusesoc_info.tex}

\subsection{In a Project}
\par
Connect the device to your AXIS bus. TUSER is used to get various options such as command/data packet mode.

\par
TDATA output will contain the 16 bit data payload. TUSER is a 8 bit command register
that outputs a description what type of data it is (command or data) and other options
described below.

TUSER = {TYY,NA,D,I,P} (7 downto 0)
\begin{itemize}
\item TYY = TYPE OF DATA
  \begin{itemize}
    \item 000 N/A
    \item 001 REG (NOT IMPLEMENTED)
    \item 010 DATA
    \item 100 CMD/STATUS
  \end{itemize}
  \item NA = RESERVED FOR FUTURE USE.
  \item D = DELAY ENABLED
  \begin{itemize}
    \item 1 = 4 us delay enabled.
    \item 0 = no delay between transmissions.
  \end{itemize}
  \item I = INVERT DATA
  \begin{itemize}
    \item 1 = Invert data.
    \item 0 = Normal data.
  \end{itemize}
  \item P = PARITY
  \begin{itemize}
    \item 1 = ODD
    \item 0 = EVEN
  \end{itemize}
\end{itemize}

\section{Architecture}
\par
This core is made up of a single module.
\begin{itemize}
  \item \textbf{axis\_1553\_decoder} Interface AXIS to PMOD1553 device (see core for documentation).
\end{itemize}

\subsection{Decoding Method}
\par
This core has 5 always blocks that are sensitive to the positive clock edge. They are

\begin{itemize}
\item \textbf{pause counter} Checks for delays between receives to comply with 4us spacing.
\item \textbf{axis data output} Deals with AXIS bus output data from the core based on its current state.
\item \textbf{data processing} In charge of the state machine and processing of 1553 non-differential bitstream to AXIS output data.
\item \textbf{skip counter} Aligns the sample counters based on the differential signal so sampling is aligned correctly.
\item \textbf{differential data input} Process data from a differential input into a non-differential one.
\end{itemize}

\par
Pause counter simply gets reset when not in the data capture or diff wait states. In those states the counter checks if the diff is equal (no input data) and counts down
till it reaches zero. This allows for detections of badly formed packets that ignore the spacing.

\par
AXIS data output does exactly as it says. Once in the transmit state, in this case this means we can transmit the decoded 1553 data over the AXIS bus. Once we are out of this state
the data is wiped.

\par
Data processing block does most of the work. It is in charge of the state machine state and decoding the 1553 non-differential bitstream. Command bit refers to the TUSER output. Essentially
the state machine does the following:
\begin{enumerate}
\item Startup in error state, which does to the default handler that puts it into diff wait.
\item In diff wait check for a change in the diff input signals. Once that has happened goto the data capture state.
\item In data capture wait for the trans\_counter to reach zero. Once at zero check the sync pulse type. Then go to data reduce, unless the pause\_counter timed out in the data capture state, then we go back to the diff wait.
\item In data reduce use the bit slice offset to capute a bit from the stream of data. Capture the parity bit, and set the output command bits for invert and delay to the correct state. Move on to parity gen.
\item In parity gen check the parity bit against the parity bit generated by the module. Set the command bit to tell the user if there is an error or not.
\item Trans just goes right back to diff wait. Only needs a cycle to let the AXIS data output to do its thing.
\end{enumerate}

\par
Skip counter is a set of conditions to reset skip counter to 0. If it is not reset the skip counter will increase. This allows us to sample the
correct bit from the oversampled stream. The conditions to reset are:
\begin{enumerate}
\item If in diff wait state and no difference in diff input, hold skip counter at current value.
\item If pause counter is 0, and no difference in diff input, reset skip counter to 0.
\item If there is a positive edge on diff, reset skip counter to 0.
\item If there is a negative edge of diff, reset skip counter to 0.
\item Error? Reset registered to all ones and skip counter to 0.
\end{enumerate}

\par
Differential data input waits for the data capture state. In this state the capture is started and the signal is sampled at the input clock. This is reduced using
a counter to pick the samples needed via the skip counter being compared to sample select. Captured data is then shifted into a register and the transmit counter
is decremented. This continues till the transmit counter is 0, or the pause counter is 0 and the diff signal is equal. All other states reset the data registers
for capturing data to its synthetic clock and the transmit counter back to its initial value before decrement.

\section{Building}

\par
The AXIS 1553 decoder is written in Verilog 2001. It should synthesize in any modern FPGA software. The core comes as a fusesoc packaged core and can be
included in any other core. Be sure to make sure you have meet the dependencies listed in the previous section.

\subsection{fusesoc}
\par
Fusesoc is a system for building FPGA software without relying on the internal project management of the tool. Avoiding vendor lock in to Vivado or Quartus.
These cores, when included in a project, can be easily integrated and targets created based upon the end developer needs. The core by itself is not a part of
a system and should be integrated into a fusesoc based system. Simulations are setup to use fusesoc and are a part of its targets.

\subsection{Source Files}

\input{src/fusesoc/files_fusesoc_info.tex}

\subsection{Targets}

\input{src/fusesoc/targets_fusesoc_info.tex}

\subsection{Directory Guide}

\par
Below highlights important folders from the root of BUS UART.

\begin{enumerate}
  \item \textbf{docs} Contains all documentation related to this project.
    \begin{itemize}
      \item \textbf{manual} Contains user manual and github page that are generated from the latex sources.
    \end{itemize}
  \item \textbf{src} Contains source files for the core
  \item \textbf{tb} Contains test bench files for iverilog and cocotb
    \begin{itemize}
      \item \textbf{cocotb} testbench files
    \end{itemize}
\end{enumerate}

\newpage

\section{Simulation}
\par
There are a few different simulations that can be run for this core.

\subsection{iverilog}
\par
iverilog is used for simple test benches for quick verification, visually, of the core.

\subsection{cocotb}
\par
Future simulations will use cocotb. This feature is not yet implemented.

\newpage

\section{Module Documentation} \label{Module Documentation}

\begin{itemize}
\item \textbf{axis\_1553\_decoder} Interfaces AXIS to the PMOD1553.\\
\end{itemize}
The next sections document the module in great detail.

